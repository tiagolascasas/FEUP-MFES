class Rome2Rio
/*
  Contains the core model of the Rome2Rio System.
  Defines the state variables and all the operations
  required to execute all use cases
*/

types
	public Status= <Administrator> | <Client>;
  public Password = seq of char;

instance variables
  public graph:Graph;
  public status : Status; 
  -- Items observable by the administrator:
  public adminCode : Password := "default"; 

operations
	-- Constructor
	public Rome2Rio : () ==> Rome2Rio
	Rome2Rio() == 
	(
		graph := new Graph();
		status := <Client>;
		return self;
	);
		
	-- Changes the type of user to admin
	public changeToAdmin : Password ==> bool
	changeToAdmin(pass) ==
	(
		if pass = adminCode then 
		(
			status := <Administrator>;
			return true;
		)
		else return false;
	)
	pre status = <Client>;
	
	/** ADMINISTRATOR OPERATIONS **/
	
	-- Changes the admin password
	public setAdministratorPassword : Password ==> ()
	setAdministratorPassword(pass) ==
		adminCode := pass
	pre status = <Administrator>;
	
	-- Adds a new location to the platform
	public addLocation : Node`Location * real * real ==> ()
	addLocation(location, coordinateNS, coordinateEW) ==
		graph.addNode(location, coordinateNS, coordinateEW)
	pre status = <Administrator>;
	
	-- Adds a connection between two locations
	public addWayBetweenLocations : Node`Location *  Node`Location * EdgeType`TravelType * nat1 * nat1 * real ==> ()
	addWayBetweenLocations(source, target, travelType, time, distance, price) ==
	(
	  if(graph.ExistsEdge(source, target) = false) then
			graph.addEdge(source, target, new EdgeType(travelType, time, distance, price))
		else 
			graph.addEdgeType(source, target, new EdgeType(travelType, time, distance, price))
			
	)
	pre status = <Administrator>;
	
	-- Adds a new transportation type to an existing connection
	public addNewTransportationType : Node`Location * Node`Location * EdgeType`TravelType * nat1 * nat1 * real ==> ()
	addNewTransportationType(source, target, type, time, distance, price) ==
	(
		dcl et: EdgeType := new EdgeType(type, time, distance, price);
		graph.addEdgeType(source, target, et);
	)
	pre type <> <ANY> and status = <Administrator>;
	
	-- Removes a location, along with all its connections
	public removeLocation : Node`Location ==> ()
	removeLocation(loc) ==
		graph.removeNode(loc)
	pre status = <Administrator>;
	
	/** CLIENT OPERATIONS **/
	
		-- Changes the type of user to client
	public changeToClient : () ==> ()
	changeToClient() ==
		status := <Client>
	pre status = <Administrator>;
	
  public  listLocations : ()  ==> nat1
  listLocations() ==
  (
  	dcl i: nat := 0;
  	for all n in set graph.node do
  	(
  		IO`print(n.location);
  		IO`print(" at (");
  		IO`print(n.coordinateNS);
  		IO`print(", ");
  		IO`print(n.coordinateEW);
  		IO`println(")");
  		i := i + 1;
  	);
  	return i;
  );
   
  public getRouteWithCriteria : Node`Location * Node`Location * EdgeType`TravelType * Graph`CriterionType ==> Path 
	getRouteWithCriteria(source, target, type, criterion) ==
		return graph.findPath(source, target, criterion, type);
  
  public getBestRoutesForAllCriteria : Node`Location *  Node`Location ==> set of (Path)
  getBestRoutesForAllCriteria(source, target) ==
  (
  	dcl paths: set of (Path) := {};
  		
  	paths := paths union {graph.findPath(source, target, <PRICE>, <ANY>)};	
  	paths := paths union {graph.findPath(source, target, <DISTANCE>, <ANY>)};	
  	paths := paths union {graph.findPath(source, target, <TIME>, <ANY>)};	
  		
  	paths := paths union {graph.findPath(source, target, <PRICE>, <CAR>)};	
  	paths := paths union {graph.findPath(source, target, <DISTANCE>, <CAR>)};	
  	paths := paths union {graph.findPath(source, target, <TIME>, <CAR>)};	
  		
  	paths := paths union {graph.findPath(source, target, <PRICE>, <BUS>)};	
  	paths := paths union {graph.findPath(source, target, <DISTANCE>, <BUS>)};	
  	paths := paths union {graph.findPath(source, target, <TIME>, <BUS>)};	
  		
  	paths := paths union {graph.findPath(source, target, <PRICE>, <PLANE>)};	
  	paths := paths union {graph.findPath(source, target, <DISTANCE>, <PLANE>)};	
  	paths := paths union {graph.findPath(source, target, <TIME>, <PLANE>)};	
  		
  	paths := paths union {graph.findPath(source, target, <PRICE>, <FERRY>)};	
  	paths := paths union {graph.findPath(source, target, <DISTANCE>, <FERRY>)};	
  	paths := paths union {graph.findPath(source, target, <TIME>, <FERRY>)};	
  		
  	paths := paths union {graph.findPath(source, target, <PRICE>, <TRAIN>)};	
  	paths := paths union {graph.findPath(source, target, <DISTANCE>, <TRAIN>)};	
  	paths := paths union {graph.findPath(source, target, <TIME>, <TRAIN>)};	

  	for all p in set paths do
  		if not p.isPossible() then paths := paths \ {p};
  		
  	return paths;
  );

end Rome2Rio
